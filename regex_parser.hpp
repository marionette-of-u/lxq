#ifndef REGEX_PARSER_HPP_
#define REGEX_PARSER_HPP_

// This file was automatically generated by Caper.
// (http://jonigata.github.io/caper/caper.html)

#include <cstdlib>
#include <cassert>
#include <vector>

namespace regex_parser {

enum Token {
    token_eof,
    token_asterisk,
    token_charactor,
    token_concat,
    token_dot,
    token_hyphen,
    token_l_bracket,
    token_l_paren,
    token_plus,
    token_question,
    token_r_bracket,
    token_r_paren,
    token_vertical_bar,
};

inline const char* token_label(Token t) {
    static const char* labels[] = {
        "token_eof",
        "token_asterisk",
        "token_charactor",
        "token_concat",
        "token_dot",
        "token_hyphen",
        "token_l_bracket",
        "token_l_paren",
        "token_plus",
        "token_question",
        "token_r_bracket",
        "token_r_paren",
        "token_vertical_bar",
    };
    return labels[t];
}

template <class T, unsigned int StackSize>
class Stack {
public:
    Stack() { gap_ = 0; }

    void rollback_tmp() {
        gap_ = stack_.size();
        tmp_.clear();
    }

    void commit_tmp() {
        // may throw
        stack_.reserve(gap_ + tmp_.size());
	   
        // expect not to throw
        stack_.erase(stack_.begin()+ gap_, stack_.end());
        stack_.insert(stack_.end(), tmp_.begin(), tmp_.end());
        tmp_.clear();
    }
    bool push(const T& f) {
        if (StackSize != 0 &&
            int(StackSize) <= int(stack_.size() + tmp_.size())) {
            return false;
        }
        tmp_.push_back(f);
        return true;
    }
	   
    void pop(size_t n) {
        if (tmp_.size() < n) {
            n -= tmp_.size();
            tmp_.clear();
            gap_ -= n;
        } else {
            tmp_.erase(tmp_.end() - n, tmp_.end());
        }
    }

    T& top() {
        assert(0 < depth());
        if (!tmp_.empty()) {
            return tmp_.back();
        } else {
            return stack_[gap_ - 1];
        }
    }
	   
    const T& get_arg(size_t base, size_t index) {
        size_t n = tmp_.size();
        if (base - index <= n) {
            return tmp_[n - (base - index)];
        } else {
            return stack_[gap_ - (base - n) + index];
        }
    }
	   
    void clear() {
        stack_.clear();
        tmp_.clear();
        gap_ = 0; 
    }
	   
    bool empty() const {
        if (!tmp_.empty()) {
            return false;
        } else {
            return gap_ == 0;
        }
    }
	   
    size_t depth() const {
        return gap_ + tmp_.size();
    }
	   
    T& nth(size_t index) {
        if (gap_ <= index) {
            return tmp_[index - gap_];
        } else {
            return stack_[index];
        }
    }

    void swap_top_and_second() {
        int d = depth();
        assert(2 <= d);
        T x = nth(d - 1);
        nth(d - 1) = nth(d - 2);
        nth(d - 2) = x;
    }

private:
    std::vector<T> stack_;
    std::vector<T> tmp_;
    size_t gap_;
	   
};

template <class Value, class SemanticAction,
          unsigned int StackSize = 0>
class Parser {
public:
    typedef Token token_type;
    typedef Value value_type;

    enum Nonterminal {
        Nonterminal_CharactorRange,
        Nonterminal_CharactorSequence,
        Nonterminal_LevelA,
        Nonterminal_LevelB,
        Nonterminal_LevelC,
        Nonterminal_S,
    };

public:
    Parser(SemanticAction& sa) : sa_(sa) { reset(); }

    void reset() {
        error_ = false;
        accepted_ = false;
        clear_stack();
        rollback_tmp_stack();
        if (push_stack(0, value_type())) {
            commit_tmp_stack();
        } else {
            sa_.stack_overflow();
            error_ = true;
        }
    }

    bool post(token_type token, const value_type& value) {
        rollback_tmp_stack();
        error_ = false;
        while ((this->*(stack_top()->entry->state))(token, value))
            ; // may throw
        if (!error_) {
            commit_tmp_stack();
        } else {
            recover(token, value);
        }
        return accepted_ || error_;
    }

    bool accept(value_type& v) {
        assert(accepted_);
        if (error_) { return false; }
        v = accepted_value_;
        return true;
    }

    bool error() { return error_; }

private:
    typedef Parser<Value, SemanticAction, StackSize> self_type;

    typedef bool (self_type::*state_type)(token_type, const value_type&);
    typedef int (self_type::*gotof_type)(Nonterminal);

    bool            accepted_;
    bool            error_;
    value_type      accepted_value_;
    SemanticAction& sa_;

    struct table_entry {
        state_type  state;
        gotof_type  gotof;
        bool        handle_error;
    };

    struct stack_frame {
        const table_entry*  entry;
        value_type          value;
        int                 sequence_length;

        stack_frame(const table_entry* e, const value_type& v, int sl)
            : entry(e), value(v), sequence_length(sl) {}
    };

    Stack<stack_frame, StackSize> stack_;

    bool push_stack(int state_index, const value_type& v, int sl = 0) {
        bool f = stack_.push(stack_frame(entry(state_index), v, sl));
        assert(!error_);
        if (!f) { 
            error_ = true;
            sa_.stack_overflow();
        }
        return f;
    }

    void pop_stack(size_t n) {
        stack_.pop(n);
    }

    stack_frame* stack_top() {
        return &stack_.top();
    }

    const value_type& get_arg(size_t base, size_t index) {
        return stack_.get_arg(base, index).value;
    }

    void clear_stack() {
        stack_.clear();
    }

    void rollback_tmp_stack() {
        stack_.rollback_tmp();
    }

    void commit_tmp_stack() {
        stack_.commit_tmp();
    }

    void recover(Token, const value_type&) {
    }

    bool call_nothing(Nonterminal nonterminal, int base) {
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, value_type());
    }

    bool call_0_make_identity(Nonterminal nonterminal, int base, int arg_index0) {
        node* arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        node* r = sa_.make_identity(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_make_charactor(Nonterminal nonterminal, int base, int arg_index0) {
        node* arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        node* r = sa_.make_charactor(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_make_dot(Nonterminal nonterminal, int base) {
        node* r = sa_.make_dot();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_make_class(Nonterminal nonterminal, int base, int arg_index0) {
        node* arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        node* r = sa_.make_class(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_make_kleene(Nonterminal nonterminal, int base, int arg_index0) {
        node* arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        node* r = sa_.make_kleene(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_make_kleene_plus(Nonterminal nonterminal, int base, int arg_index0) {
        node* arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        node* r = sa_.make_kleene_plus(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_make_one_or_zero(Nonterminal nonterminal, int base, int arg_index0) {
        node* arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        node* r = sa_.make_one_or_zero(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_make_seq(Nonterminal nonterminal, int base, int arg_index0) {
        node* arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        node* r = sa_.make_seq(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_1_make_seq(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        node* arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        node* arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        node* r = sa_.make_seq(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_make_class_range(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        node* arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        node* arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        node* r = sa_.make_class_range(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_1_make_class_range(Nonterminal nonterminal, int base, int arg_index0) {
        node* arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        node* r = sa_.make_class_range(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_make_or(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        node* arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        node* arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        node* r = sa_.make_or(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_make_concat(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        node* arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        node* arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        node* r = sa_.make_concat(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_make_range(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        node* arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        node* arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        node* r = sa_.make_range(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool state_0(token_type token, const value_type& value) {
        switch(token) {
        case token_charactor:
            // shift
            push_stack(/*state*/ 12, value);
            return false;
        case token_dot:
            // shift
            push_stack(/*state*/ 13, value);
            return false;
        case token_l_bracket:
            // shift
            push_stack(/*state*/ 14, value);
            return false;
        case token_l_paren:
            // shift
            push_stack(/*state*/ 5, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_0(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_S: return 1;
        case Nonterminal_LevelA: return 8;
        case Nonterminal_LevelB: return 3;
        case Nonterminal_LevelC: return 2;
        default: assert(0); return false;
        }
    }

    bool state_1(token_type token, const value_type& value) {
        switch(token) {
        case token_eof:
            // accept
            accepted_ = true;
            accepted_value_ = get_arg(1, 0);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_1(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_2(token_type token, const value_type& value) {
        switch(token) {
        case token_eof:
            // reduce
            return call_0_make_identity(Nonterminal_S, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_2(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_3(token_type token, const value_type& value) {
        switch(token) {
        case token_charactor:
            // shift
            push_stack(/*state*/ 12, value);
            return false;
        case token_dot:
            // shift
            push_stack(/*state*/ 13, value);
            return false;
        case token_l_bracket:
            // shift
            push_stack(/*state*/ 14, value);
            return false;
        case token_l_paren:
            // shift
            push_stack(/*state*/ 5, value);
            return false;
        case token_vertical_bar:
            // shift
            push_stack(/*state*/ 4, value);
            return false;
        case token_eof:
        case token_r_paren:
            // reduce
            return call_0_make_identity(Nonterminal_LevelC, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_3(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_LevelA: return 8;
        case Nonterminal_LevelB: return 3;
        case Nonterminal_LevelC: return 7;
        default: assert(0); return false;
        }
    }

    bool state_4(token_type token, const value_type& value) {
        switch(token) {
        case token_charactor:
            // shift
            push_stack(/*state*/ 12, value);
            return false;
        case token_dot:
            // shift
            push_stack(/*state*/ 13, value);
            return false;
        case token_l_bracket:
            // shift
            push_stack(/*state*/ 14, value);
            return false;
        case token_l_paren:
            // shift
            push_stack(/*state*/ 5, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_4(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_LevelA: return 8;
        case Nonterminal_LevelB: return 3;
        case Nonterminal_LevelC: return 6;
        default: assert(0); return false;
        }
    }

    bool state_5(token_type token, const value_type& value) {
        switch(token) {
        case token_charactor:
            // shift
            push_stack(/*state*/ 12, value);
            return false;
        case token_dot:
            // shift
            push_stack(/*state*/ 13, value);
            return false;
        case token_l_bracket:
            // shift
            push_stack(/*state*/ 14, value);
            return false;
        case token_l_paren:
            // shift
            push_stack(/*state*/ 5, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_5(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_LevelA: return 8;
        case Nonterminal_LevelB: return 3;
        case Nonterminal_LevelC: return 17;
        default: assert(0); return false;
        }
    }

    bool state_6(token_type token, const value_type& value) {
        switch(token) {
        case token_eof:
        case token_r_paren:
            // reduce
            return call_0_make_or(Nonterminal_LevelC, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_6(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_7(token_type token, const value_type& value) {
        switch(token) {
        case token_eof:
        case token_r_paren:
            // reduce
            return call_0_make_concat(Nonterminal_LevelC, /*pop*/ 2, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_7(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_8(token_type token, const value_type& value) {
        switch(token) {
        case token_asterisk:
            // shift
            push_stack(/*state*/ 9, value);
            return false;
        case token_plus:
            // shift
            push_stack(/*state*/ 10, value);
            return false;
        case token_question:
            // shift
            push_stack(/*state*/ 11, value);
            return false;
        case token_eof:
        case token_charactor:
        case token_dot:
        case token_l_bracket:
        case token_l_paren:
        case token_r_paren:
        case token_vertical_bar:
            // reduce
            return call_0_make_identity(Nonterminal_LevelB, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_8(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_9(token_type token, const value_type& value) {
        switch(token) {
        case token_eof:
        case token_charactor:
        case token_dot:
        case token_l_bracket:
        case token_l_paren:
        case token_r_paren:
        case token_vertical_bar:
            // reduce
            return call_0_make_kleene(Nonterminal_LevelB, /*pop*/ 2, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_9(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_10(token_type token, const value_type& value) {
        switch(token) {
        case token_eof:
        case token_charactor:
        case token_dot:
        case token_l_bracket:
        case token_l_paren:
        case token_r_paren:
        case token_vertical_bar:
            // reduce
            return call_0_make_kleene_plus(Nonterminal_LevelB, /*pop*/ 2, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_10(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_11(token_type token, const value_type& value) {
        switch(token) {
        case token_eof:
        case token_charactor:
        case token_dot:
        case token_l_bracket:
        case token_l_paren:
        case token_r_paren:
        case token_vertical_bar:
            // reduce
            return call_0_make_one_or_zero(Nonterminal_LevelB, /*pop*/ 2, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_11(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_12(token_type token, const value_type& value) {
        switch(token) {
        case token_eof:
        case token_asterisk:
        case token_charactor:
        case token_dot:
        case token_l_bracket:
        case token_l_paren:
        case token_plus:
        case token_question:
        case token_r_paren:
        case token_vertical_bar:
            // reduce
            return call_0_make_charactor(Nonterminal_LevelA, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_12(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_13(token_type token, const value_type& value) {
        switch(token) {
        case token_eof:
        case token_asterisk:
        case token_charactor:
        case token_dot:
        case token_l_bracket:
        case token_l_paren:
        case token_plus:
        case token_question:
        case token_r_paren:
        case token_vertical_bar:
            // reduce
            return call_0_make_dot(Nonterminal_LevelA, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_13(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_14(token_type token, const value_type& value) {
        switch(token) {
        case token_charactor:
            // shift
            push_stack(/*state*/ 19, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_14(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_CharactorSequence: return 15;
        case Nonterminal_CharactorRange: return 21;
        default: assert(0); return false;
        }
    }

    bool state_15(token_type token, const value_type& value) {
        switch(token) {
        case token_charactor:
            // shift
            push_stack(/*state*/ 20, value);
            return false;
        case token_r_bracket:
            // shift
            push_stack(/*state*/ 16, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_15(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_CharactorRange: return 22;
        default: assert(0); return false;
        }
    }

    bool state_16(token_type token, const value_type& value) {
        switch(token) {
        case token_eof:
        case token_asterisk:
        case token_charactor:
        case token_dot:
        case token_l_bracket:
        case token_l_paren:
        case token_plus:
        case token_question:
        case token_r_paren:
        case token_vertical_bar:
            // reduce
            return call_0_make_class(Nonterminal_LevelA, /*pop*/ 3, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_16(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_17(token_type token, const value_type& value) {
        switch(token) {
        case token_r_paren:
            // shift
            push_stack(/*state*/ 18, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_17(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_18(token_type token, const value_type& value) {
        switch(token) {
        case token_eof:
        case token_asterisk:
        case token_charactor:
        case token_dot:
        case token_l_bracket:
        case token_l_paren:
        case token_plus:
        case token_question:
        case token_r_paren:
        case token_vertical_bar:
            // reduce
            return call_0_make_identity(Nonterminal_LevelA, /*pop*/ 3, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_18(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_19(token_type token, const value_type& value) {
        switch(token) {
        case token_hyphen:
            // shift
            push_stack(/*state*/ 23, value);
            return false;
        case token_charactor:
        case token_r_bracket:
            // reduce
            return call_0_make_seq(Nonterminal_CharactorSequence, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_19(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_20(token_type token, const value_type& value) {
        switch(token) {
        case token_hyphen:
            // shift
            push_stack(/*state*/ 23, value);
            return false;
        case token_charactor:
        case token_r_bracket:
            // reduce
            return call_1_make_seq(Nonterminal_CharactorSequence, /*pop*/ 2, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_20(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_21(token_type token, const value_type& value) {
        switch(token) {
        case token_charactor:
        case token_r_bracket:
            // reduce
            return call_1_make_class_range(Nonterminal_CharactorSequence, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_21(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_22(token_type token, const value_type& value) {
        switch(token) {
        case token_charactor:
        case token_r_bracket:
            // reduce
            return call_0_make_class_range(Nonterminal_CharactorSequence, /*pop*/ 2, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_22(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_23(token_type token, const value_type& value) {
        switch(token) {
        case token_charactor:
            // shift
            push_stack(/*state*/ 24, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_23(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_24(token_type token, const value_type& value) {
        switch(token) {
        case token_charactor:
        case token_r_bracket:
            // reduce
            return call_0_make_range(Nonterminal_CharactorRange, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_24(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    const table_entry* entry(int n) const {
        static const table_entry entries[] = {
            { &Parser::state_0, &Parser::gotof_0, false },
            { &Parser::state_1, &Parser::gotof_1, false },
            { &Parser::state_2, &Parser::gotof_2, false },
            { &Parser::state_3, &Parser::gotof_3, false },
            { &Parser::state_4, &Parser::gotof_4, false },
            { &Parser::state_5, &Parser::gotof_5, false },
            { &Parser::state_6, &Parser::gotof_6, false },
            { &Parser::state_7, &Parser::gotof_7, false },
            { &Parser::state_8, &Parser::gotof_8, false },
            { &Parser::state_9, &Parser::gotof_9, false },
            { &Parser::state_10, &Parser::gotof_10, false },
            { &Parser::state_11, &Parser::gotof_11, false },
            { &Parser::state_12, &Parser::gotof_12, false },
            { &Parser::state_13, &Parser::gotof_13, false },
            { &Parser::state_14, &Parser::gotof_14, false },
            { &Parser::state_15, &Parser::gotof_15, false },
            { &Parser::state_16, &Parser::gotof_16, false },
            { &Parser::state_17, &Parser::gotof_17, false },
            { &Parser::state_18, &Parser::gotof_18, false },
            { &Parser::state_19, &Parser::gotof_19, false },
            { &Parser::state_20, &Parser::gotof_20, false },
            { &Parser::state_21, &Parser::gotof_21, false },
            { &Parser::state_22, &Parser::gotof_22, false },
            { &Parser::state_23, &Parser::gotof_23, false },
            { &Parser::state_24, &Parser::gotof_24, false },
        };
        return &entries[n];
    }

};

} // namespace regex_parser

#endif // #ifndef REGEX_PARSER_HPP_

